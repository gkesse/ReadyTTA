C51 COMPILER V8.12   GSCH                                                                  08/09/2017 18:50:09 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE GSCH
OBJECT MODULE PLACED IN .\GSch.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\manager\GSch.c BROWSE DEBUG OBJECTEXTEND PRINT(.\GSch.lst) OBJECT(.\
                    -GSch.obj)

line level    source

   1          //===============================================
   2          #include "GSch.h"
   3          #include "GPortDef.h"
   4          //===============================================
   5          #define PRELOAD01 (65536 - ((OSC_FREQ * 1) / (OSC_PER_INST * 1000))) // ms
   6          #define PRELOAD01H (PRELOAD01 / 256)
   7          #define PRELOAD01L (PRELOAD01 % 256)
   8          //===============================================
   9          #define SCH_MAX_TASKS 1
  10          //===============================================
  11          GTask Sch_Tasks_Map[SCH_MAX_TASKS];
  12          //===============================================
  13          void GSch_Go_To_Sleep();
  14          void GSch_Delete_Task(const uchar index);
  15          //===============================================
  16          void GSch_Init() {
  17   1              uchar index;
  18   1              for(index = 0; index < SCH_MAX_TASKS; index++) {
  19   2                      GSch_Delete_Task(index);
  20   2              }
  21   1          T2CON = 0x00; 
  22   1          TH2 = PRELOAD01H; 
  23   1          RCAP2H = PRELOAD01H; 
  24   1          TL2 = PRELOAD01L; 
  25   1          RCAP2L = PRELOAD01L;
  26   1          ET2 = 1;
  27   1          TR2 = 1;
  28   1      }
  29          //===============================================
  30          void GSch_Start() {
  31   1              EA = 1;
  32   1      }
  33          //===============================================
  34          void GSch_Go_To_Sleep() {
  35   1              PCON |= 0x01;
  36   1      }
  37          //===============================================
  38          void GSch_Dispatch_Tasks() {
  39   1              uchar index;
  40   1              for(index = 0; index < SCH_MAX_TASKS; index++) {
  41   2                      if(Sch_Tasks_Map[index].runMe > 0) {
  42   3                              (*Sch_Tasks_Map[index].pTask)();
  43   3                              Sch_Tasks_Map[index].runMe -= 1;
  44   3                              if(Sch_Tasks_Map[index].period == 0) {
  45   4                                      GSch_Delete_Task(index);
  46   4                              }
  47   3                      }
  48   2              }
  49   1              GSch_Go_To_Sleep();
  50   1      }
  51          //===============================================
  52          void GSch_Add_Task(void (*pTask)(), const uint delay, const uint period) {
  53   1              uchar index = 0;
  54   1              while((Sch_Tasks_Map[index].pTask != 0) && (index < SCH_MAX_TASKS)) index++;
C51 COMPILER V8.12   GSCH                                                                  08/09/2017 18:50:09 PAGE 2   

  55   1              if(index == SCH_MAX_TASKS) return;
  56   1              Sch_Tasks_Map[index].pTask = pTask;
  57   1              Sch_Tasks_Map[index].delay = delay;
  58   1              Sch_Tasks_Map[index].period = period;
  59   1              Sch_Tasks_Map[index].runMe = 0;
  60   1      }
  61          //===============================================
  62          void GSch_Delete_Task(const uchar index) {
  63   1              Sch_Tasks_Map[index].pTask = 0x0000;
  64   1              Sch_Tasks_Map[index].delay = 0;
  65   1              Sch_Tasks_Map[index].period = 0;
  66   1              Sch_Tasks_Map[index].runMe = 0;
  67   1      }
  68          //===============================================
  69          void GSch_Update() interrupt INTERRUPT_TIMER_2 {
  70   1              uchar index;
  71   1              TF2 = 0;
  72   1              for(index = 0; index < SCH_MAX_TASKS; index++) {
  73   2                      if(Sch_Tasks_Map[index].pTask != 0) {
  74   3                              if(Sch_Tasks_Map[index].delay == 0) {
  75   4                                      Sch_Tasks_Map[index].runMe += 1;
  76   4                                      if(Sch_Tasks_Map[index].period != 0) {
  77   5                                              Sch_Tasks_Map[index].delay = Sch_Tasks_Map[index].period;
  78   5                                      }
  79   4                              }
  80   3                              else {
  81   4                                      Sch_Tasks_Map[index].delay -= 1;
  82   4                              }
  83   3                      }
  84   2              }
  85   1      }
  86          //===============================================


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    401    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
